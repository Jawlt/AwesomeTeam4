import os
import pickle
import json
from googleapiclient.discovery import build
from google_auth_oauthlib.flow import InstalledAppFlow
from google.auth.transport.requests import Request
from openai import OpenAI
from dotenv import load_dotenv
from pydantic import BaseModel
import hashlib
from googleapiclient.errors import HttpError


load_dotenv()

client_id = os.getenv('GOOGLE_CLIENT_ID')
client_secret = os.getenv('GOOGLE_CLIENT_SECRET')
project_id = os.getenv('GOOGLE_PROJECT_ID')
auth_uri = os.getenv('GOOGLE_AUTH_URI')
token_uri = os.getenv('GOOGLE_TOKEN_URI')
auth_provider_cert_url = os.getenv('GOOGLE_AUTH_PROVIDER_CERT_URL')
redirect_uris = os.getenv('GOOGLE_REDIRECT_URIS').split(',')

client_secrets = {
    "installed": {
        "client_id": client_id,
        "project_id": project_id,
        "auth_uri": auth_uri,
        "token_uri": token_uri,
        "auth_provider_x509_cert_url": auth_provider_cert_url,
        "client_secret": client_secret,
        "redirect_uris": redirect_uris
    }
}


# OpenAI client setup
openai_client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))

SCOPES = [
    'https://www.googleapis.com/auth/presentations',
    'https://www.googleapis.com/auth/drive'
]

# Define Pydantic models for slide data
class Slide(BaseModel):
    title: str
    bullets: list[str]
    script: str

class GPTSlides(BaseModel):
    slides: list[Slide]


# Function to generate slide content using OpenAI
def generate_slide_content(topic, title, goals, information):
    prompt = f"""
    Generate json content for a training topic on {title}. The learning goals of the training are {goals}. Make the response for highly educated and smart individuals. Provide four slides, where the first slide is an intro. The 3 remaining slides focus on content:
    - A title
    - A body (a list of 3 bullet points, with good detail)
    - A script (a paragraph of text)

    Use the following context for facts in the bullet points: {information}
    """
    response = openai_client.beta.chat.completions.parse(
        model="gpt-4o-2024-08-06",
        messages=[
            {"role": "system", "content": "You are a helpful assistant."},
            {"role": "user", "content": prompt}
        ],
        max_tokens=1000,
        response_format=GPTSlides
    )
    
    content = response.choices[0].message.parsed
    return content

# Function to sanitize and shorten object IDs
def sanitize_object_id(id_str):
    # Remove spaces and invalid characters first
    sanitized = ''.join([c if c.isalnum() or c in ['_', '-', ':'] else '_' for c in id_str])
    
    # Truncate or hash the sanitized string to ensure it's under 50 characters
    # Limit to the first 10 characters or use a hash of the string (substring of the first 10 chars of the hash)
    if len(sanitized) > 50:
        sanitized = hashlib.md5(sanitized.encode()).hexdigest()[:10]  # Take first 10 chars of the hash
    
    return sanitized

def create_slides(service, presentation_id, slide_data):
    populate_requests = []
    create_slide_requests = []

    # Get the presentation to retrieve slide IDs
    presentation = service.presentations().get(presentationId=presentation_id).execute()
    slides = presentation.get('slides', [])
    
    # Delete the first slide (autogenerated title slide)
    if slides:
        first_slide_id = slides[0]['objectId']
        delete_slide_request = {
            'deleteObject': {
                'objectId': first_slide_id
            }
        }
        # Add the delete slide request to the batch
        populate_requests.append(delete_slide_request)

    # Create slides in the presentation
    for slide in slide_data.slides:
        create_slide_request = {
            'createSlide': {}
        }
        create_slide_requests.append(create_slide_request)

    create_slide_response = service.presentations().batchUpdate(
        presentationId=presentation_id,
        body={'requests': create_slide_requests}
    ).execute()

    # Get the created slide IDs
    created_slide_ids = [
        reply['createSlide']['objectId']
        for reply in create_slide_response['replies']
    ]

    for i, (slide, slide_id) in enumerate(zip(slide_data.slides, created_slide_ids)):
        # Common logic for all slides (intro slide is also handled here now)
        
        # Slide title element ID
        title_element_id = sanitize_object_id(f"TitleBox_{slide.title}")
        body_element_id = sanitize_object_id(f"BodyBox_{slide.title}")

        # Create title text box
        requests = [
            {
                "createShape": {
                    "objectId": title_element_id,
                    "shapeType": "TEXT_BOX",
                    "elementProperties": {
                        "pageObjectId": slide_id,  # Use the slide's objectId
                        "size": {"height": {"magnitude": 60, "unit": "PT"}, "width": {"magnitude": 500, "unit": "PT"}},
                        "transform": {"scaleX": 1, "scaleY": 1, "translateX": 50, "translateY": 50, "unit": "PT"}
                    }
                }
            },
            {
                "insertText": {
                    "objectId": title_element_id,
                    "insertionIndex": 0,
                    "text": slide.title
                }
            },
            {
                "updateTextStyle": {
                    "objectId": title_element_id,
                    "textRange": {
                        "type": "ALL"
                    },
                    "style": {
                        "fontSize": {
                            "magnitude": 24,  # Font size for the title
                            "unit": "PT"
                        },
                        "bold": True  # Bold the title
                    },
                    "fields": "fontSize,bold"
                }
            },
            # Create body text box with bullet points
            {
                "createShape": {
                    "objectId": body_element_id,
                    "shapeType": "TEXT_BOX",
                    "elementProperties": {
                        "pageObjectId": slide_id,
                        "size": {"height": {"magnitude": 250, "unit": "PT"}, "width": {"magnitude": 500, "unit": "PT"}},
                        "transform": {"scaleX": 1, "scaleY": 1, "translateX": 50, "translateY": 120, "unit": "PT"}
                    }
                }
            },
            {
                "insertText": {
                    "objectId": body_element_id,
                    "insertionIndex": 0,
                    "text": '\n'.join(slide.bullets)  # Bullet points from slide
                }
            },
            {
                "createParagraphBullets": {
                    "objectId": body_element_id,
                    "textRange": {"type": "ALL"},
                    "bulletPreset": "BULLET_DISC_CIRCLE_SQUARE"
                }
            },
        ]

        populate_requests.extend(requests)

    # Execute the requests to create and populate slides
    if populate_requests:
        service.presentations().batchUpdate(
            presentationId=presentation_id,
            body={'requests': populate_requests}
        ).execute()

    print("Slides created and populated successfully.")



def publish_presentation(creds, presentation_id):
    try:
        # Create the Drive API service using the credentials
        drive_service = build('drive', 'v3', credentials=creds)

        # Update the permissions to make the file publicly viewable
        permissions = {
            'type': 'anyone',
            'role': 'reader'
        }

        drive_service.permissions().create(
            fileId=presentation_id,
            body=permissions
        ).execute()

        print(f"Presentation {presentation_id} has been published and is now publicly viewable.")
    except HttpError as error:
        print(f"An error occurred while publishing the presentation: {error}")

def main(title, goals, information):
    creds = None

    # If there's a saved token
    if os.path.exists('token.pickle'):
        with open('token.pickle', 'rb') as token:
            creds = pickle.load(token)

    # If no valid credentials exist, prompt the user to log in
    if not creds or not creds.valid:
        if creds and creds.expired and creds.refresh_token:
            creds.refresh(Request())
        else:
            flow = InstalledAppFlow.from_client_config(client_secrets, SCOPES)
            creds = flow.run_local_server(port=8080)
        with open('token.pickle', 'wb') as token:
            pickle.dump(creds, token)

    print(title, goals, information)
    try:
        service = build('slides', 'v1', credentials=creds)

        # Create a new presentation
        body = {'title': 'Generated Presentation'}
        presentation = service.presentations().create(body=body).execute()
        presentation_id = presentation.get('presentationId')
        print(f"Created presentation with ID: {presentation_id}")

        # Generate slide content
        topic = "Artificial Intelligence"
        content = generate_slide_content(topic, title, goals, information)
        print(f"Generated content: {content}")

        # Create slides from the generated content
        create_slides(service, presentation_id, content)
        print("Slides created successfully.")

        # Publish the presentation and get the URL
        publish_presentation(creds, presentation_id)  # Pass the creds here
        presentation_url = f"https://docs.google.com/presentation/d/{presentation_id}/embed"
        print(f"Your presentation is available at: {presentation_url}")
        scripts = []
        for slide in content.slides:
            scripts.append(slide.script)
        return [presentation_id, scripts]


    except Exception as e:
        print(f"An error occurred: {e}")


if __name__ == '__main__':
    main()